##### 前言

我们都知道在多线程环境下，为了保证线程安全，经常会使用到synchronized来进行加锁操作。同时又有很多人用synchronized和Lock锁来进行比较，我们经常使用sychronized来进行加锁操作可能就是觉得它方便，它会自己去自动释放锁，给我们带来了便利。但是要想在日常开发中使用好这个关键字，底层原理还是有必要弄明白。

synchronized是JDK自带的一个关键字，在JDK1.5之前是一个重量级锁，但是在JDK1.6后对其进行了优化，引入了偏向锁，轻量级锁，自旋锁等概念。



##### 什么是同步

同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。



##### sychronized使用场景

###### 修饰实例方法，相当于对当前实例对象this加锁，this作为对象监视器。

```

```



###### synchronized关键字

synchronized关键字经过编译之后，会在同步块得前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果java程序中的synchronized明确的指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或class对象来作为锁对象。

每一个对象都有一个监视器锁（monitor）

###### 虚拟机规范

根据虚拟机规范要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，知道对象锁被另外一个线程释放为止。

###### 注意两点:

synchronized同步块对同一线程来说是可重入的，不会出现自己把自己锁死的情况

同步块在已进入的线程执行之前，会阻塞后面其他线程进入。

